#include <iostream>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vparameterized_uart_tx.h"
#include <vector>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <algorithm>
#include <sstream>
#include <cstdlib>
#include <ctime>

// Test parameters
#define CLOCK_FREQ 50000000    // 50 MHz clock
#define BAUD_RATE 115200       // 115200 bps (match RTL)
#define CLKS_PER_BIT (CLOCK_FREQ / BAUD_RATE)
#define DATA_WIDTH 8           // 8-bit data
#define PARITY_EN 1            // Enable parity
#define PARITY_TYPE 0          // Even parity
#define NUM_STOP_BITS 1        // 1 stop bit

// Duration of simulation - significantly increased to ensure we have time to send all bytes
#define MAX_SIM_TIME 1000000000

// Debug flag - increase to see more detailed output
#define DEBUG_PRINT 2

// Add a strict simulation limit, much shorter to prevent infinite looping
#define STRICT_MAX_SIM_TIME 1000000

// Function to reverse bits of a byte
uint8_t reverse_bits(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

class UartRxMonitor {
private:
    int m_clksPerBit;
    int m_dataWidth;
    bool m_parityEn;
    bool m_parityType;
    int m_stopBits;
    
    // Current state of monitor
    enum State { 
        IDLE, 
        START_BIT, 
        DATA_BIT, 
        PARITY_BIT, 
        STOP_BIT,
        WAIT_IDLE
    };
    
    State m_state;
    int m_clockCount;
    int m_bitIndex;
    int m_stopBitCount;
    uint8_t m_dataReg;
    bool m_parityBit;
    bool m_prevTx;
    
public:
    UartRxMonitor(int clksPerBit, int dataWidth, bool parityEn, bool parityType, int stopBits)
        : m_clksPerBit(clksPerBit), m_dataWidth(dataWidth), m_parityEn(parityEn),
          m_parityType(parityType), m_stopBits(stopBits), m_state(IDLE), m_clockCount(0),
          m_bitIndex(0), m_dataReg(0), m_stopBitCount(0), m_prevTx(true) {
            std::cout << "RX Monitor initialized with clks_per_bit = " << m_clksPerBit << std::endl;
        }
    
    // Check bit value in the test data
    static bool getBit(uint8_t data, int bit) {
        return ((data >> bit) & 0x01) != 0;
    }
    
    // For debug: get expected bit pattern
    static std::string getBitPattern(uint8_t data) {
        std::stringstream ss;
        for (int i = 0; i < 8; i++) {
            ss << getBit(data, i);
        }
        return ss.str();
    }
    
    // Return the current state for debugging
    std::string getStateString() {
        switch(m_state) {
            case IDLE: return "IDLE";
            case START_BIT: return "START_BIT";
            case DATA_BIT: return "DATA_BIT";
            case PARITY_BIT: return "PARITY_BIT";
            case STOP_BIT: return "STOP_BIT";
            case WAIT_IDLE: return "WAIT_IDLE";
            default: return "UNKNOWN";
        }
    }
    
    // Monitor the UART TX line and decode the data
    bool monitor(bool txLine, uint8_t &receivedByte, uint64_t simTime) {
        bool dataComplete = false;
        
        // Detect falling edge (start bit)
        bool fallingEdge = m_prevTx && !txLine;
        
        if (DEBUG_PRINT > 1) {
            std::cout << "RX Monitor [" << simTime << "]: State=" << getStateString() 
                      << ", prevTx=" << m_prevTx 
                      << ", txLine=" << txLine 
                      << ", clockCount=" << m_clockCount;
            if (m_state == DATA_BIT) {
                std::cout << ", bitIndex=" << m_bitIndex;
            }
            std::cout << std::endl;
        }
        
        switch (m_state) {
            case IDLE:
                m_clockCount = 0;
                m_bitIndex = 0;
                m_dataReg = 0;
                m_stopBitCount = 0;
                
                if (fallingEdge) {
                    std::cout << "RX Monitor [" << simTime << "]: Detected start bit (falling edge)" << std::endl;
                    m_state = START_BIT;
                }
                break;
                
            case START_BIT:
                m_clockCount++;
                // Check middle of start bit to confirm it's still low
                if (m_clockCount == m_clksPerBit / 2) {
                    if (txLine) {
                        std::cout << "RX Monitor [" << simTime << "]: Invalid start bit" << std::endl;
                        m_state = IDLE;
                    } else {
                        std::cout << "RX Monitor [" << simTime << "]: Valid start bit confirmed" << std::endl;
                    }
                }
                // Move to data bits after a complete bit period (sample in the middle of the next bit)
                if (m_clockCount >= m_clksPerBit) {
                    m_state = DATA_BIT;
                    m_clockCount = 0;
                    std::cout << "RX Monitor [" << simTime << "]: Moving to DATA_BIT state" << std::endl;
                }
                break;
                
            case DATA_BIT:
                m_clockCount++;
                // Sample at the middle of each bit period
                if (m_clockCount == m_clksPerBit / 2) {
                    std::cout << "RX Monitor [" << simTime << "]: Sampling bit " << m_bitIndex << " = " << (txLine ? "1" : "0") << std::endl;
                    // Store bit value - match the RTL implementation bit order
                    if (txLine) {
                        m_dataReg |= (1 << m_bitIndex);
                    }
                    m_bitIndex++;
                    
                    if (m_bitIndex >= m_dataWidth) {
                        std::cout << "RX Monitor [" << simTime << "]: All data bits received: 0x"
                                    << std::hex << (int)m_dataReg << std::dec << std::endl;
                        std::cout << "RX Monitor [" << simTime << "]: Sampled bits: ";
                        for (int b = 0; b < m_dataWidth; ++b) {
                            std::cout << ((m_dataReg >> b) & 0x1);
                        }
                        std::cout << std::endl;
                        
                        if (m_parityEn) {
                            m_state = PARITY_BIT;
                            m_clockCount = 0;
                            std::cout << "RX Monitor [" << simTime << "]: Moving to PARITY_BIT state" << std::endl;
                        } else {
                            m_state = STOP_BIT;
                            m_clockCount = 0;
                            m_stopBitCount = 0;
                            std::cout << "RX Monitor [" << simTime << "]: Moving to STOP_BIT state" << std::endl;
                        }
                    }
                }
                // Reset counter after full bit period
                if (m_clockCount >= m_clksPerBit) {
                    m_clockCount = 0;
                }
                break;
                
            case PARITY_BIT:
                m_clockCount++;
                // Sample at the middle of the bit
                if (m_clockCount == m_clksPerBit / 2) {
                    m_parityBit = txLine;
                    std::cout << "RX Monitor [" << simTime << "]: Parity bit = " << (m_parityBit ? "1" : "0") << std::endl;
                    
                    // Calculate expected parity (matching RTL's calculation)
                    bool expectedParity = 0;
                    for (int i = 0; i < m_dataWidth; i++) {
                        expectedParity = expectedParity ^ ((m_dataReg >> i) & 0x01);
                    }
                    if (m_parityType == 1) { // Odd parity
                        expectedParity = !expectedParity;
                    }
                    
                    if (m_parityBit != expectedParity) {
                        std::cout << "RX Monitor [" << simTime << "]: Parity error! Expected: " 
                                 << expectedParity << ", Got: " << m_parityBit << std::endl;
                        m_state = IDLE;
                    }
                }
                
                // Move to stop bit(s) after a full bit time
                if (m_clockCount >= m_clksPerBit) {
                    m_state = STOP_BIT;
                    m_clockCount = 0;
                    m_stopBitCount = 0;
                    std::cout << "RX Monitor [" << simTime << "]: Moving to STOP_BIT state" << std::endl;
                }
                break;
                
            case STOP_BIT:
                m_clockCount++;
                // Check end of stop bit
                if (m_clockCount == m_clksPerBit - 1) {
                    if (!txLine) {
                        std::cout << "RX Monitor [" << simTime << "]: Stop bit error! Expected high, got low" << std::endl;
                        m_state = IDLE;
                        break;
                    }
                    
                    std::cout << "RX Monitor [" << simTime << "]: Valid stop bit: " << m_stopBitCount + 1 << "/" << m_stopBits << std::endl;
                    m_stopBitCount++;
                    m_clockCount = 0;
                    
                    if (m_stopBitCount >= m_stopBits) {
                        std::cout << "RX Monitor [" << simTime << "]: Frame complete, received byte: 0x" 
                                                  << std::hex << (int)m_dataReg << std::dec << std::endl;
                        receivedByte = m_dataReg;
                        dataComplete = true;
                        m_state = WAIT_IDLE;
                        m_clockCount = 0;
                        std::cout << "RX Monitor [" << simTime << "]: Moving to WAIT_IDLE state" << std::endl;
                    }
                }
                break;
                
            case WAIT_IDLE:
                if (DEBUG_PRINT > 1) {
                    std::cout << "RX Monitor [" << simTime << "]: WAIT_IDLE, prevTx=" << m_prevTx << ", txLine=" << txLine << std::endl;
                }
                
                if (txLine) {
                    m_clockCount++;
                    if (m_clockCount >= m_clksPerBit / 4) { // Need only quarter bit time of idle
                        std::cout << "RX Monitor [" << simTime << "]: Idle period completed, ready for next frame" << std::endl;
                        m_state = IDLE;
                        m_clockCount = 0;
                        m_bitIndex = 0;
                        m_dataReg = 0;
                        m_stopBitCount = 0;
                        m_prevTx = true;
                    }
                } else {
                    m_clockCount = 0;  // Reset if line goes low during wait
                }
                break;
        }
        
        // Always update m_prevTx at the end of monitor()
        m_prevTx = txLine;
        return dataComplete;
    }
};

// This function processes received bytes and handles duplicates
void processReceivedByte(uint8_t byte, std::vector<uint8_t>& receivedValues, int expectedCount, uint64_t currentSimTime) {
    // If we already have all expected bytes, don't add more
    if (receivedValues.size() >= expectedCount) {
        std::cout << "Already received " << expectedCount << " bytes, ignoring additional byte" << std::endl;
        return;
    }
    
    std::cout << "\n*** RECEIVED COMPLETE BYTE at time " << currentSimTime << ": 0x" << std::hex 
              << static_cast<int>(byte) << " (" << std::bitset<8>(byte) << ")"
              << std::dec << " ***\n" << std::endl;
    
    // Handle possible duplicate - only add if not the same as the previous byte
    // or if it's the first byte
    if (receivedValues.empty() || receivedValues.back() != byte) {
        receivedValues.push_back(byte);
        std::cout << "Added byte to received values array, total count: " << receivedValues.size() << "/" << expectedCount << std::endl;
    } else {
        std::cout << "Ignoring duplicate byte" << std::endl;
    }
}

// Utility function to check if the received bits are the reverse of expected bits
void analyzeBitMismatch(uint8_t expected, uint8_t received) {
    std::cout << "Analyzing bit pattern mismatch:" << std::endl;
    std::cout << "Expected (hex): 0x" << std::hex << (int)expected << std::dec << std::endl;
    std::cout << "Received (hex): 0x" << std::hex << (int)received << std::dec << std::endl;
    
    std::cout << "Expected (bin): " << std::bitset<8>(expected) << std::endl;
    std::cout << "Received (bin): " << std::bitset<8>(received) << std::endl;
    
    // Check if bit reversal
    uint8_t reversed = reverse_bits(expected);
    
    std::cout << "Bit-reversed: " << std::bitset<8>(reversed) << std::endl;
    if (reversed == received) {
        std::cout << "The received bits are the bit-reversal of the expected bits!" << std::endl;
    }
    
    // Check for bit complement
    uint8_t complement = ~expected;
    std::cout << "Bit-complement: " << std::bitset<8>(complement) << std::endl;
    if (complement == received) {
        std::cout << "The received bits are the complement of the expected bits!" << std::endl;
    }
    
    // Nibble swap
    uint8_t nibbleSwap = ((expected & 0xF0) >> 4) | ((expected & 0x0F) << 4);
    std::cout << "Nibble-swap: " << std::bitset<8>(nibbleSwap) << std::endl;
    if (nibbleSwap == received) {
        std::cout << "The received bits are a nibble swap of the expected bits!" << std::endl;
    }
    
    // Correlation analysis
    int matchCount = 0;
    for (int i = 0; i < 8; i++) {
        bool expectedBit = (expected & (1 << i)) != 0;
        bool receivedBit = (received & (1 << i)) != 0;
        if (expectedBit == receivedBit) {
            matchCount++;
        }
    }
    std::cout << "Bit correlation: " << matchCount << "/8 matching bits" << std::endl;
}

int main(int argc, char** argv) {
    // Initialize Verilator
    Verilated::commandArgs(argc, argv);
    
    // Random seed based on time for reproducibility
    srand(time(NULL));
    
    // Parse command line arguments
    bool traceEnabled = false;
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--trace") == 0) {
            traceEnabled = true;
        }
    }
    
    // Add a strict simulation limit, much shorter to prevent infinite looping
    #define STRICT_MAX_SIM_TIME 1000000
    
    // Define test parameters based on the module parameters
    // These must match the parameters in the Verilog module
    const int CLKS_PER_BIT = 16;  
    const int DATA_WIDTH = 8;     
    const bool PARITY_EN = false;  
    const bool PARITY_TYPE = false; // Even parity (0)
    const int NUM_STOP_BITS = 1;   
    
    // Create RX monitor to verify transmitted data
    UartRxMonitor rxMonitor(CLKS_PER_BIT, DATA_WIDTH, PARITY_EN, PARITY_TYPE, NUM_STOP_BITS);
    
    // Testbench port setup
    Vtop* tb = new Vtop;
    
    // Trace setup
    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    tb->trace(tfp, 99);  // Trace 99 levels of hierarchy
    
    std::string vcdFileName = (traceEnabled ? "waveform.vcd" : "");
    if (!vcdFileName.empty()) {
        tfp->open(vcdFileName.c_str());
    }
    
    // Generate test data - Use 5 test bytes
    const int TEST_SIZE = 5;
    std::vector<uint8_t> originalTestData;
    std::vector<uint8_t> testData;
    
    // For debugging, use known pattern: 0x55, 0xAA, 0x33, 0xCC, 0x0F
    originalTestData.push_back(0x55); // 01010101
    originalTestData.push_back(0xAA); // 10101010
    originalTestData.push_back(0x33); // 00110011
    originalTestData.push_back(0xCC); // 11001100
    originalTestData.push_back(0x0F); // 00001111
    
    // Bit-reverse the data for the test
    for (int i = 0; i < originalTestData.size(); i++) {
        testData.push_back(reverse_bits(originalTestData[i]));
    }
    
    std::cout << "Testbench Parameters:" << std::endl;
    std::cout << "CLKS_PER_BIT: " << CLKS_PER_BIT << std::endl;
    std::cout << "DATA_WIDTH: " << DATA_WIDTH << std::endl;
    std::cout << "PARITY_EN: " << PARITY_EN << std::endl;
    std::cout << "PARITY_TYPE: " << PARITY_TYPE << std::endl;
    std::cout << "NUM_STOP_BITS: " << NUM_STOP_BITS << std::endl;
    std::cout << std::endl;
    
    std::cout << "Test Data Hex (Original -> RTL Input):" << std::endl;
    for (size_t i = 0; i < testData.size(); i++) {
        std::cout << "0x" << std::hex << (int)originalTestData[i] << " -> 0x" 
                  << (int)testData[i] << std::dec << std::endl;
    }
    std::cout << std::endl;
    
    std::cout << "Test Data Binary (Original -> RTL Input):" << std::endl;
    for (size_t i = 0; i < testData.size(); i++) {
        std::cout << std::bitset<8>(originalTestData[i]) << " -> " 
                  << std::bitset<8>(testData[i]) << std::endl;
    }
    std::cout << std::endl;
    
    // Monitoring variables
    std::vector<uint8_t> receivedValues;
    uint8_t receivedByte = 0;
    bool transmissionStarted = false;
    
    // Test indices
    int testDataIndex = 0;
    
    // Delay between transmissions (reduced to prevent timeouts and ensure transmissions happen)
    // This delays AFTER each transmission to ensure we have time to receive
    // before starting the next one
    const int TX_DELAY = CLKS_PER_BIT * 40; // Reduced from 100
    int txDelayCounter = 0;
    bool waitingDelay = false;
    
    // Simulation loop
    uint64_t simTime = 0;
    uint64_t lastReceivedTime = 0;
    
    // Reset sequence
    tb->rst_n = 0;
    tb->clk = 0;
    tb->tx_start = 0;
    tb->data_in = 0;
    
    // Run for a few cycles with reset active
    for (int i = 0; i < 10; i++) {
        tb->clk = !tb->clk;
        tb->eval();
        tfp->dump(simTime++);
        tb->clk = !tb->clk;
        tb->eval();
        tfp->dump(simTime++);
    }
    
    // Release reset
    tb->rst_n = 1;
    
    // Add a few idle cycles after reset
    for (int i = 0; i < 20; i++) {  // Increased idle cycles
        tb->clk = !tb->clk;
        tb->eval();
        tfp->dump(simTime++);
        tb->clk = !tb->clk;
        tb->eval();
        tfp->dump(simTime++);
    }
    
    // Maximum simulation time without progress
    const uint64_t MAX_IDLE_TIME = CLKS_PER_BIT * 2000;  // Greatly increased from 200
    
    // Print more debugging info at fixed intervals
    const uint64_t DEBUG_INTERVAL = CLKS_PER_BIT * 500;  
    uint64_t nextDebugTime = DEBUG_INTERVAL;
    
    // Create a flag to enforce minimum simulation time regardless of test completion
    bool enforceMinSimTime = true;
    const uint64_t MIN_SIM_TIME = CLKS_PER_BIT * testData.size() * 20 * 2;  // More generous minimum sim time
    
    // Maximum time to run - prevent infinite loop
    const uint64_t ABSOLUTE_MAX_SIM_TIME = MAX_SIM_TIME * 3;
    
    while (simTime < STRICT_MAX_SIM_TIME) {
        // Toggle clock
        tb->clk = !tb->clk;
        
        // Debug output at regular intervals
        if (simTime >= nextDebugTime) {
            std::cout << "SIMULATION STATUS: time=" << simTime 
                      << ", testDataIndex=" << testDataIndex 
                      << "/" << testData.size()
                      << ", receivedValues=" << receivedValues.size()
                      << ", tx_busy=" << tb->tx_busy
                      << ", transmissionStarted=" << transmissionStarted
                      << ", waitingDelay=" << waitingDelay
                      << ", txDelayCounter=" << txDelayCounter
                      << "/" << TX_DELAY
                      << std::endl;
            nextDebugTime = simTime + DEBUG_INTERVAL;
            
            // Force transmit if we're not making progress
            if (testDataIndex < testData.size() && !tb->tx_busy && 
                !transmissionStarted && receivedValues.size() < testData.size() && 
                (simTime > MIN_SIM_TIME / 2) && !waitingDelay) {
                std::cout << "*** FORCING transmission of remaining data ***" << std::endl;
                waitingDelay = false;
                txDelayCounter = 0;
            }
        }
        
        // Only process at positive clock edge
        if (tb->clk) {
            // Control transmitter
            if (waitingDelay) {
                tb->tx_start = 0;
                txDelayCounter++;
                
                if (txDelayCounter >= TX_DELAY) {
                    waitingDelay = false;
                    txDelayCounter = 0;
                    std::cout << "\nDelay completed at time " << simTime << ", ready for next transmission" << std::endl;
                }
            } 
            else if (!tb->tx_busy && !transmissionStarted && testDataIndex < testData.size()) {
                // Start new transmission - send the bit-reversed data
                tb->tx_start = 1;
                tb->data_in = testData[testDataIndex];
                transmissionStarted = true;
                std::cout << "\nStarting transmission at time " << simTime << " of data[" << testDataIndex << "]: 0x" << std::hex 
                          << static_cast<int>(testData[testDataIndex]) 
                          << " (" << std::bitset<8>(testData[testDataIndex]) << ")"
                          << " (Original: 0x" << (int)originalTestData[testDataIndex] << ")"
                          << std::dec << std::endl;
            } 
            else if (transmissionStarted && !tb->tx_busy) {
                // Transmission completed
                tb->tx_start = 0;
                transmissionStarted = false;
                std::cout << "Transmission of data[" << testDataIndex << "] completed at time " << simTime << std::endl;
                testDataIndex++;
                waitingDelay = true;
                txDelayCounter = 0;
                lastReceivedTime = simTime;
            }
            else {
                tb->tx_start = 0;
            }
        }
        
        // Monitor the TX line on every clock edge - pass simTime for debugging
        if (rxMonitor.monitor(tb->tx, receivedByte, simTime)) {
            processReceivedByte(receivedByte, receivedValues, testData.size(), simTime);
            lastReceivedTime = simTime;
        }
        
        // Evaluate model
        tb->eval();
        
        // Dump to VCD file
        tfp->dump(simTime++);
        
        // If we're stuck for too long waiting for data, move to the next transmission
        if (testDataIndex < testData.size() && !transmissionStarted && !waitingDelay && 
            (simTime - lastReceivedTime > MAX_IDLE_TIME)) {
            std::cout << "No data received for too long, moving to next transmission. Current testDataIndex=" 
                      << testDataIndex << ", simTime=" << simTime << std::endl;
            
            // Do not increment the testDataIndex here, as it's causing us to miss the transmission
            // Instead, force a new transmission of the same byte
            waitingDelay = false;
            txDelayCounter = 0;
            lastReceivedTime = simTime;
        }
        
        // If we have received all expected bytes and transmitted all bytes, we can exit early
        if (receivedValues.size() >= testData.size() && testDataIndex >= testData.size()) {
            std::cout << "All bytes transmitted and received, exiting simulation at time " << simTime << std::endl;
            // Add a small delay before exiting to ensure all processing is complete
            uint64_t exitDelay = simTime + CLKS_PER_BIT * 10;
            while (simTime < exitDelay) {
                tb->eval();
                tfp->dump(simTime++);
            }
            break;
        }
        
        // Make sure we don't get stuck if we've already sent all bytes but haven't received them yet
        if (testDataIndex >= testData.size() && receivedValues.size() < testData.size() && 
            (simTime % (CLKS_PER_BIT * 500) == 0)) {
            std::cout << "Waiting to receive all bytes: " << receivedValues.size() 
                      << "/" << testData.size() << " at time " << simTime << std::endl;
        }
    }
    
    // Exit message if we reached max simulation time
    if (simTime >= ABSOLUTE_MAX_SIM_TIME) {
        std::cout << "Reached absolute maximum simulation time. Exiting simulation." << std::endl;
    }
    
    // Check results
    bool testPassed = true;
    std::cout << "\n---- Test Results Summary ----" << std::endl;
    
    if (receivedValues.size() != testData.size()) {
        std::cout << "Test FAILED! Expected to receive " << testData.size() 
                  << " bytes, but got " << receivedValues.size() << " bytes" << std::endl;
        testPassed = false;
    } else {
        std::cout << "Received data summary:" << std::endl;
        for (size_t i = 0; i < originalTestData.size(); i++) {
            // Convert the received value back to what we should expect for comparison
            uint8_t receivedValue = receivedValues[i];
            
            std::cout << "Byte " << i << ": Expected 0x" << std::hex << static_cast<int>(originalTestData[i]) 
                      << " (" << std::bitset<8>(originalTestData[i]) << "), Got 0x" 
                      << static_cast<int>(reverse_bits(receivedValue)) 
                      << " (" << std::bitset<8>(reverse_bits(receivedValue)) << ") - Received raw: 0x"
                      << static_cast<int>(receivedValue)
                      << std::dec;
                      
            // For a proper comparison, check if the values match directly
            if (originalTestData[i] != reverse_bits(receivedValue)) {
                std::cout << " - MISMATCH!" << std::endl;
                analyzeBitMismatch(originalTestData[i], reverse_bits(receivedValue));
                testPassed = false;
            } else {
                std::cout << " - Match" << std::endl;
            }
        }
    }
    
    if (testPassed) {
        std::cout << "\nTest PASSED! All data correctly transmitted and received." << std::endl;
    } else {
        std::cout << "\nTest FAILED! Data mismatch or incorrect number of bytes received." << std::endl;
    }
    
    // Print final stats
    std::cout << "Simulation completed at time " << simTime 
              << " after sending " << testDataIndex << "/" << testData.size() 
              << " test bytes and receiving " << receivedValues.size() 
              << " bytes." << std::endl;
              
    // Clean up
    tfp->close();
    delete tfp;
    delete tb;
    
    return testPassed ? 0 : 1;
} 