# Coding & Encoding Modules
*A Comprehensive Guide to Digital Coding Implementations*

## Table of Contents
- [Introduction](#introduction)
- [Code Conversion](#code-conversion)
  - [Binary to Gray Code](#binary-to-gray-code)
  - [Gray to Binary Code](#gray-to-binary-code)
- [Error Detection and Correction](#error-detection-and-correction)
  - [Hamming Code](#hamming-code)
  - [Cyclic Redundancy Check (CRC)](#cyclic-redundancy-check-crc)
- [Data Manipulation](#data-manipulation)
  - [Scrambler/Descrambler](#scramblerdescrambler)
- [Priority Encoding](#priority-encoding)
  - [Basic Priority Encoder](#basic-priority-encoder)
  - [Configurable Priority Encoder](#configurable-priority-encoder)
- [Performance Considerations](#performance-considerations)
- [Applications](#applications)
- [Implementation Examples](#implementation-examples)
- [References](#references)

## Introduction

Coding and encoding techniques are fundamental operations in digital systems, used for data representation, error detection/correction, communication protocols, and resource arbitration. This library provides a collection of parameterizable, reusable modules that implement common coding algorithms used across various digital design applications.

Each module is designed with configurability in mind, making them adaptable to different bit widths and requirements while maintaining efficient hardware implementation.

## Code Conversion

### Binary to Gray Code

**Description**: Converts standard binary representation to Gray code, where adjacent code words differ by only one bit.

**Principles of Operation**:
- Gray code is generated by XORing each binary bit with its higher adjacent bit
- The MSB remains unchanged from binary to Gray code

**Implementation**:
```verilog
// Gray code conversion: gray_out = binary_in ^ (binary_in >> 1)
assign gray_out[WIDTH-1] = binary_in[WIDTH-1];

genvar i;
generate
    for (i = 0; i < WIDTH-1; i = i + 1) begin : gen_gray
        assign gray_out[i] = binary_in[i] ^ binary_in[i+1];
    end
endgenerate
```

**Applications**:
- Analog-to-digital converters
- Rotary encoders
- State machines to prevent glitches during state transitions
- Counters where only one bit changes at a time

### Gray to Binary Code

**Description**: Converts Gray code back to standard binary representation.

**Principles of Operation**:
- Conversion uses cumulative XOR operations from MSB to LSB
- The MSB remains unchanged from Gray to binary

**Implementation**:
```verilog
// Convert Gray code to binary using cumulative XOR operations
always @(*) begin
    binary_out[WIDTH-1] = gray_in[WIDTH-1];
    
    for (i = WIDTH-2; i >= 0; i = i - 1) begin
        binary_out[i] = binary_out[i+1] ^ gray_in[i];
    end
end
```

**Applications**:
- Decoding Gray code from sensors
- Digital signal processing
- Communication systems

## Error Detection and Correction

### Hamming Code

**Description**: Implements error detection and correction using Hamming coding, capable of detecting and correcting single-bit errors.

**Principles of Operation**:
- Uses additional parity bits to provide redundancy
- Parity bits are placed at positions that are powers of 2
- Each parity bit checks specific bit positions according to the Hamming code algorithm
- Can detect and correct single-bit errors by calculating the syndrome

**Key Features**:
- Parameterizable data width
- Single-bit error detection and correction
- Provides both encoded and corrected outputs

**Implementation Example** (for 4-bit data):
```verilog
// Encoder: Calculate parity bits
wire p1 = data_in[0] ^ data_in[1] ^ data_in[3];
wire p2 = data_in[0] ^ data_in[2] ^ data_in[3];
wire p3 = data_in[1] ^ data_in[2] ^ data_in[3];

// Decoder: Calculate syndrome
wire s1 = received_in[0] ^ received_in[2] ^ received_in[4] ^ received_in[6];
wire s2 = received_in[1] ^ received_in[2] ^ received_in[5] ^ received_in[6];
wire s3 = received_in[3] ^ received_in[4] ^ received_in[5] ^ received_in[6];

// Error position from syndrome
wire [2:0] syndrome = {s3, s2, s1};
```

**Applications**:
- Memory systems (ECC memory)
- Communication channels with low noise
- Critical data storage where single-bit errors must be corrected

### Cyclic Redundancy Check (CRC)

**Description**: A highly configurable error detection code using polynomial division to generate checksums.

**Principles of Operation**:
- Data is treated as a polynomial and divided by a generator polynomial
- The remainder becomes the CRC value
- Detects burst errors and random errors
- Different polynomials provide different error detection capabilities

**Key Features**:
- Configurable data width and CRC width
- Selectable CRC polynomial
- Options for input/output reflection
- Configurable initial and final XOR values
- Commonly used standards easily implemented (CRC-8, CRC-16, CRC-32)

**Implementation**:
```verilog
// Calculate next CRC value
function [CRC_WIDTH-1:0] next_crc;
    input [CRC_WIDTH-1:0] crc;
    input [WIDTH-1:0] data;
    reg [CRC_WIDTH-1:0] next;
    integer i;
    begin
        next = crc;
        
        for (i = 0; i < WIDTH; i = i + 1) begin
            next = {next[CRC_WIDTH-2:0], 1'b0} ^ 
                   ((next[CRC_WIDTH-1] ^ data[WIDTH-1-i]) ? POLY : 0);
        end
        
        next_crc = next;
    end
endfunction
```

**Applications**:
- Network communication protocols
- Storage systems (HDD, SSD, flash)
- File transfer verification
- Data integrity checking

## Data Manipulation

### Scrambler/Descrambler

**Description**: Implements a Linear Feedback Shift Register (LFSR) based scrambler/descrambler for data whitening.

**Principles of Operation**:
- Uses an LFSR to generate a pseudo-random sequence
- Data is XORed with this sequence for scrambling
- Same circuit can be used for both scrambling and descrambling
- Two modes: reset-based and self-synchronized

**Key Features**:
- Configurable polynomial and LFSR width
- User-defined initial seed
- Two operating modes:
  - Reset-based: Requires synchronized initialization between transmitter and receiver
  - Self-synchronized: Uses input data for synchronization

**Implementation**:
```verilog
// Calculate feedback based on polynomial taps
assign feedback = ^(lfsr_reg & POLYNOMIAL);

// Output is XOR of input and LFSR LSB
assign data_out = data_in ^ lfsr_reg[0];
```

**Applications**:
- Digital communication systems
- Data whitening to avoid long sequences of identical bits
- Spread spectrum techniques
- Magnetic/optical storage systems

## Priority Encoding

### Basic Priority Encoder

**Description**: Encodes a multi-hot input vector to the binary representation of the highest priority active bit.

**Principles of Operation**:
- Scans input from MSB to LSB to find the first active bit
- Outputs the binary representation of the highest priority bit position
- Provides a valid output signal when at least one input is active

**Implementation**:
```verilog
// Priority encoding logic (MSB has highest priority)
for (i = WIDTH-1; i >= 0; i = i - 1) begin
    if (in[i]) begin
        out = i[OUT_WIDTH-1:0];
        valid = 1;
        i = -1;  // Break the loop
    end
end
```

**Applications**:
- Arbitration logic
- Interrupt controllers
- Task schedulers
- Resource allocation

### Configurable Priority Encoder

**Description**: An enhanced priority encoder with configurable input and output widths.

**Principles of Operation**:
- Similar operation to the basic encoder but with additional configurability
- Handles arbitrary width inputs
- Automatic calculation of required output width
- Multiple implementation options for simulator compatibility

**Implementation**:
```verilog
// Alternative implementation using casez
casez (request)
    {INPUT_WIDTH{1'b0}}: begin
        // All zeros case
        valid = 1'b0;
        grant_index = {OUTPUT_WIDTH{1'b0}};
    end
    default: begin
        // Find the highest priority bit (MSB)
        valid = 1'b1;
        
        // Priority encoding logic
        for (i = INPUT_WIDTH-1; i >= 0; i = i - 1) begin
            if (request[i]) begin
                grant_index = i[OUTPUT_WIDTH-1:0];
                i = -1; // Force exit from the loop
            end
        end
    end
endcase
```

**Applications**:
- Complex arbitration systems
- Multi-core processor designs
- Network packet schedulers
- Resource managers

## Performance Considerations

### Area and Timing Trade-offs

| Module | Area | Timing Path | Scalability |
|--------|------|-------------|-------------|
| Binary/Gray Conversions | Low | Short | Excellent |
| Hamming Code | Medium | Medium | Good for small data widths |
| CRC Generator | Medium-High | Medium | Good |
| Scrambler | Low | Short | Excellent |
| Priority Encoder | Low | Depends on width | Good |

### Implementation Guidelines

- **Binary/Gray Conversions**: Purely combinational, suitable for high-frequency designs
- **Hamming Code**: Consider pipelining for larger data widths
- **CRC Generator**: 
  - Bit-serial implementation is area-efficient but slower
  - Lookup table approaches can be used for higher throughput
- **Scrambler/Descrambler**: Keep polynomials with few taps for reduced logic
- **Priority Encoder**: For very large widths, consider hierarchical implementations

## Applications

### Communication Systems
- Scramblers prevent DC bias and long runs of identical bits
- CRC ensures data integrity
- Gray code reduces transition errors
- Hamming codes provide forward error correction

### Storage Systems
- CRC for block integrity verification
- ECC (Hamming) for memory protection
- Scramblers for uniform data patterns in magnetic/optical media

### Digital Control
- Priority encoders for arbitration and scheduling
- Gray counters for smooth state transitions
- Error detection for control plane integrity

### Signal Processing
- Encoders/decoders for DSP applications
- Data transformation for algorithm optimization

## Implementation Examples

### Ethernet CRC-32
```verilog
// Ethernet CRC-32 configuration
parameter CRC_WIDTH = 32;
parameter [31:0] POLY = 32'h04C11DB7;  // IEEE 802.3 polynomial
parameter [31:0] INIT = 32'hFFFFFFFF;  // Initial value (all ones)
parameter [31:0] XOR_OUT = 32'hFFFFFFFF;  // Final XOR value
parameter INPUT_REFLECTED = 1;  // Reflect input bytes
parameter RESULT_REFLECTED = 1;  // Reflect output result
```

### 8B/10B Encoder (Conceptual)
```verilog
// Conceptual implementation for 8B/10B encoding
module encoder_8b10b (
    input [7:0] data_in,
    input k_in,  // Control signal
    output [9:0] data_out,
    output disparity_out
);
    // 5b/6b and 3b/4b tables would be implemented
    // with running disparity tracking
endmodule
```

## References

- "Error Control Coding" by Shu Lin and Daniel J. Costello
- "Digital Communications" by John G. Proakis and Masoud Salehi
- "FPGA Prototyping by Verilog Examples" by Pong P. Chu
- IEEE 802.3 Ethernet Standard (for CRC-32)
- ITU-T Recommendation V.42 (for CRC-16)
- "Introduction to Error-Correcting Codes" by Michael Purser 