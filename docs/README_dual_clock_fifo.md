# Dual-Clock FIFO

## Overview
This is a parameterized dual-clock FIFO (First-In-First-Out) buffer implementation in Verilog. It allows data to be written and read using different clock domains, making it suitable for clock domain crossing applications. The FIFO uses gray code pointers to ensure reliable synchronization between the two clock domains.

## Features
- Parameterized data width and address width
- Configurable almost-full and almost-empty thresholds
- Asynchronous reset
- Gray code pointer synchronization for reliable clock domain crossing
- Status flags: empty, full, almost_empty, almost_full
- FIFO depth count output

## Parameters
- `DATA_WIDTH`: Width of the data bus (default: 8 bits)
- `ADDR_WIDTH`: Address width determining the FIFO depth (FIFO depth = 2^ADDR_WIDTH)
- `ALMOST_FULL_THRESHOLD`: Threshold for asserting the almost_full flag
- `ALMOST_EMPTY_THRESHOLD`: Threshold for asserting the almost_empty flag

## Ports

### Write Domain
- `wr_clk`: Write clock
- `wr_rst_n`: Active-low asynchronous reset for write domain
- `wr_en`: Write enable
- `wr_data`: Data input
- `full`: Full flag
- `almost_full`: Almost full flag

### Read Domain
- `rd_clk`: Read clock
- `rd_rst_n`: Active-low asynchronous reset for read domain
- `rd_en`: Read enable
- `rd_data`: Data output
- `empty`: Empty flag
- `almost_empty`: Almost empty flag
- `fifo_count`: Number of entries in the FIFO (synchronous to read clock)

## Implementation Details
- The FIFO uses a memory array to store data
- Write and read pointers are maintained in binary format for address calculation
- Gray code versions of the pointers are used for synchronization between clock domains
- Two-stage synchronization is used to prevent metastability issues
- Empty and full flags are generated by comparing synchronized gray code pointers
- Almost-empty and almost-full flags are generated using configurable thresholds

## Usage Example
```verilog
// Instantiate a 16-deep FIFO with 8-bit data width
dual_clock_fifo #(
    .DATA_WIDTH(8),
    .ADDR_WIDTH(4),
    .ALMOST_FULL_THRESHOLD(12),
    .ALMOST_EMPTY_THRESHOLD(4)
) fifo_inst (
    // Write domain
    .wr_clk(wr_clk),
    .wr_rst_n(wr_rst_n),
    .wr_en(wr_en),
    .wr_data(wr_data),
    .full(full),
    .almost_full(almost_full),
    
    // Read domain
    .rd_clk(rd_clk),
    .rd_rst_n(rd_rst_n),
    .rd_en(rd_en),
    .rd_data(rd_data),
    .empty(empty),
    .almost_empty(almost_empty),
    
    // Status
    .fifo_count(fifo_count)
);
```

## Verification
The module has been verified using Verilator with a C++ testbench that:
1. Tests initial conditions
2. Tests filling the FIFO completely
3. Tests emptying the FIFO completely
4. Tests concurrent read and write operations with alternating clock edges

## Limitations and Considerations
- The FIFO depth is limited to 2^ADDR_WIDTH
- Gray code synchronization adds latency to status flag updates
- Care should be taken when using almost_full and almost_empty flags as they may not be accurate during rapid transitions
- The FIFO count is synchronous to the read clock and may not reflect the most recent writes 